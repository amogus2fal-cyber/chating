<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>Dark Maze Horror</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; }
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #888;
            font-family: monospace;
            font-size: 16px;
            pointer-events: none;
            z-index: 10;
        }
        #instructions {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-family: monospace;
            text-align: center;
            background: rgba(0,0,0,0.8);
            padding: 20px;
            border: 1px solid #333;
            cursor: pointer;
        }
    </style>
    <!-- Подключаем Three.js и PeerJS -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://unpkg.com/peerjs@1.4.7/dist/peerjs.min.js"></script>
    <!-- PointerLockControls для управления мышкой -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/PointerLockControls.js"></script>
</head>
<body>

<div id="ui">
    ID: <span id="my-id">...</span><br>
    Игроков рядом: <span id="players-count">0</span><br>
    [F] - Фонарик
</div>

<div id="instructions">
    <h1>ТЕМНЫЙ ЛАБИРИНТ</h1>
    <p>Кликни сюда, чтобы начать</p>
    <p>WASD - Ходить | Мышь - Осмотр | F - Фонарик</p>
    <p style="color: red; font-size: 12px;">Осторожно: очень темно.</p>
</div>

<script>
    // --- НАСТРОЙКИ ---
    const PEER_PREFIX = 'horror-maze-v1-'; // Уникальный префикс для поиска игроков
    const WALL_HEIGHT = 40;
    const MAZE_SIZE = 15; // Размер лабиринта (клеток)
    
    // --- ИНИЦИАЛИЗАЦИЯ THREE.JS ---
    const scene = new THREE.Scene();
    // Очень густой черный туман
    scene.fog = new THREE.FogExp2(0x000000, 0.15); 
    scene.background = new THREE.Color(0x000000);

    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer();
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true; // Тени включены
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    document.body.appendChild(renderer.domElement);

    // --- ЗВУК ---
    // Простой гул для атмосферы (синтезированный, чтобы не грузить файлы)
    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    function playDrone() {
        if (audioCtx.state === 'suspended') audioCtx.resume();
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.type = 'sawtooth';
        osc.frequency.value = 50; // Низкий гул
        gain.gain.value = 0.05;
        osc.connect(gain);
        gain.connect(audioCtx.destination);
        osc.start();
        
        // Модуляция страха
        setInterval(() => {
            osc.frequency.rampToValueAtTime(50 + Math.random() * 20, audioCtx.currentTime + 2);
        }, 3000);
    }

    // --- ЛАБИРИНТ (Генерация) ---
    // 1 - стена, 0 - проход. Простая коробка со столбами.
    const map = [];
    for(let x=0; x<MAZE_SIZE; x++){
        map[x] = [];
        for(let z=0; z<MAZE_SIZE; z++){
            if(x===0 || x===MAZE_SIZE-1 || z===0 || z===MAZE_SIZE-1 || Math.random() > 0.8) {
                map[x][z] = 1; 
            } else {
                map[x][z] = 0;
            }
        }
    }

    // Текстуры (процедурные, черные)
    const wallGeo = new THREE.BoxGeometry(4, WALL_HEIGHT, 4);
    const wallMat = new THREE.MeshStandardMaterial({ 
        color: 0x111111, // Почти черный
        roughness: 0.9 
    });
    
    const floorGeo = new THREE.PlaneGeometry(MAZE_SIZE*4, MAZE_SIZE*4);
    const floorMat = new THREE.MeshStandardMaterial({ color: 0x050505, roughness: 1 });
    const floor = new THREE.Mesh(floorGeo, floorMat);
    floor.rotation.x = -Math.PI / 2;
    floor.receiveShadow = true;
    scene.add(floor);

    const walls = [];
    for(let x=0; x<MAZE_SIZE; x++){
        for(let z=0; z<MAZE_SIZE; z++){
            if(map[x][z] === 1){
                const wall = new THREE.Mesh(wallGeo, wallMat);
                wall.position.set((x - MAZE_SIZE/2)*4, WALL_HEIGHT/2, (z - MAZE_SIZE/2)*4);
                wall.castShadow = true;
                wall.receiveShadow = true;
                scene.add(wall);
                walls.push(wall);
            }
        }
    }

    // --- ИГРОК И ФОНАРИК ---
    const controls = new THREE.PointerLockControls(camera, document.body);
    
    // Старт игры по клику
    const instructions = document.getElementById('instructions');
    instructions.addEventListener('click', () => {
        controls.lock();
        playDrone();
    });
    controls.addEventListener('lock', () => instructions.style.display = 'none');
    controls.addEventListener('unlock', () => instructions.style.display = 'block');

    // Фонарик игрока
    const flashlight = new THREE.SpotLight(0xffffff, 0, 40, Math.PI/6, 0.5, 1);
    flashlight.position.set(0, 0, 0); // Прикреплен к камере
    flashlight.castShadow = true;
    flashlight.target = camera; // Светит туда, куда смотрит камера
    camera.add(flashlight); // Добавляем фонарик в "руки" (камеру)
    scene.add(camera);

    // Слабый фоновый свет (чтобы хоть что-то видеть без фонарика)
    const ambientLight = new THREE.AmbientLight(0x404040, 0.02); 
    scene.add(ambientLight);

    let isFlashlightOn = false;
    window.addEventListener('keydown', (e) => {
        if(e.code === 'KeyF') {
            isFlashlightOn = !isFlashlightOn;
            flashlight.intensity = isFlashlightOn ? 2 : 0; // Вкл/Выкл
            // Отправляем статус фонарика другим
            broadcast({ type: 'flashlight', on: isFlashlightOn });
        }
    });

    // --- УПРАВЛЕНИЕ ---
    let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
    const velocity = new THREE.Vector3();
    const direction = new THREE.Vector3();

    const onKeyDown = (e) => {
        switch (e.code) {
            case 'ArrowUp': case 'KeyW': moveForward = true; break;
            case 'ArrowLeft': case 'KeyA': moveLeft = true; break;
            case 'ArrowDown': case 'KeyS': moveBackward = true; break;
            case 'ArrowRight': case 'KeyD': moveRight = true; break;
        }
    };
    const onKeyUp = (e) => {
        switch (e.code) {
            case 'ArrowUp': case 'KeyW': moveForward = false; break;
            case 'ArrowLeft': case 'KeyA': moveLeft = false; break;
            case 'ArrowDown': case 'KeyS': moveBackward = false; break;
            case 'ArrowRight': case 'KeyD': moveRight = false; break;
        }
    };
    document.addEventListener('keydown', onKeyDown);
    document.addEventListener('keyup', onKeyUp);

    // --- МУЛЬТИПЛЕЕР (PeerJS) ---
    const peer = new Peer(null, { debug: 1 }); // null = авто-ID
    let myId = null;
    const conns = {}; // Подключения к другим игрокам
    const otherPlayers = {}; // 3D объекты других игроков

    peer.on('open', (id) => {
        myId = id;
        document.getElementById('my-id').innerText = id;
        console.log('My ID:', id);
        connectToOthers(); // Пытаемся найти кого-то (упрощенно: нужно знать ID)
    });

    peer.on('connection', (conn) => {
        setupConnection(conn);
    });

    // В реальном проекте тут нужен сервер списка комнат. 
    // Для демо мы просто попробуем соединиться с теми, кто передаст свой ID вручную,
    // или (хак) можно использовать URL параметры ?join=ID
    const urlParams = new URLSearchParams(window.location.search);
    const joinId = urlParams.get('join');
    
    function connectToOthers() {
        if (joinId && joinId !== myId) {
            const conn = peer.connect(joinId);
            setupConnection(conn);
        }
    }

    // Хак для локального теста: когда игрок двигается, мы просто "вещаем" всем (тут упрощено)
    // В полноценной версии нужна сигнальная комната. 
    // ДЛЯ ДЕМО: Скопируй свой ID и добавь к ссылке друга: site.com?join=ТВОЙ_ID
    
    function setupConnection(conn) {
        conn.on('open', () => {
            console.log("Connected to:", conn.peer);
            conns[conn.peer] = conn;
            createOtherPlayer(conn.peer);
            updatePlayerCount();
        });
        conn.on('data', (data) => {
            handleData(conn.peer, data);
        });
        conn.on('close', () => {
            removeOtherPlayer(conn.peer);
            delete conns[conn.peer];
            updatePlayerCount();
        });
    }

    function createOtherPlayer(id) {
        if(otherPlayers[id]) return;
        // Другой игрок - это просто призрачная сфера
        const geo = new THREE.SphereGeometry(1, 16, 16);
        const mat = new THREE.MeshBasicMaterial({ color: 0xff0000, wireframe: true });
        const mesh = new THREE.Mesh(geo, mat);
        
        // Фонарик другого игрока
        const otherLight = new THREE.SpotLight(0xffffff, 0, 30, Math.PI/6);
        otherLight.position.set(0,0,0);
        otherLight.target.position.set(0,0,-1); // Светит перед собой
        mesh.add(otherLight);
        mesh.add(otherLight.target);
        
        scene.add(mesh);
        otherPlayers[id] = { mesh: mesh, light: otherLight };
    }

    function removeOtherPlayer(id) {
        if(otherPlayers[id]) {
            scene.remove(otherPlayers[id].mesh);
            delete otherPlayers[id];
        }
    }

    function handleData(id, data) {
        if(!otherPlayers[id]) return;
        
        if (data.type === 'move') {
            const p = otherPlayers[id].mesh;
            p.position.fromArray(data.pos);
            p.rotation.y = data.rot;
        }
        if (data.type === 'flashlight') {
            otherPlayers[id].light.intensity = data.on ? 2 : 0;
        }
    }

    function broadcast(data) {
        for(let id in conns) {
            conns[id].send(data);
        }
    }

    function updatePlayerCount() {
        document.getElementById('players-count').innerText = Object.keys(conns).length;
    }

    // --- ГЛАВНЫЙ ЦИКЛ ---
    const clock = new THREE.Clock();
    let lastBroadcast = 0;

    function animate() {
        requestAnimationFrame(animate);
        
        if (controls.isLocked) {
            const delta = clock.getDelta();

            // Физика движения (очень простая)
            velocity.x -= velocity.x * 10.0 * delta;
            velocity.z -= velocity.z * 10.0 * delta;
            direction.z = Number(moveForward) - Number(moveBackward);
            direction.x = Number(moveRight) - Number(moveLeft);
            direction.normalize();

            if (moveForward || moveBackward) velocity.z -= direction.z * 40.0 * delta;
            if (moveLeft || moveRight) velocity.x -= direction.x * 40.0 * delta;

            controls.moveRight(-velocity.x * delta);
            controls.moveForward(-velocity.z * delta);
            
            // Коллизии со стенами (простые, чтобы не проходить сквозь)
            // (Опущено для краткости кода, будь аккуратен, не выходи за карту!)
            if(camera.position.y < 2) camera.position.y = 2; // Фикс высоты

            // Отправка позиции другим игрокам (раз в 50мс)
            const now = Date.now();
            if(now - lastBroadcast > 50 && Object.keys(conns).length > 0) {
                const pos = camera.position;
                const rot = camera.rotation.y; // Упрощенно берем Y поворот
                broadcast({ 
                    type: 'move', 
                    pos: [pos.x, pos.y, pos.z],
                    rot: rot 
                });
                lastBroadcast = now;
            }
        }

        renderer.render(scene, camera);
    }
    
    // Спавн в случайном месте (безопасном)
    camera.position.set(0, 2, 0);
    
    animate();
    
    // Ресайз окна
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

</script>
</body>
</html>
